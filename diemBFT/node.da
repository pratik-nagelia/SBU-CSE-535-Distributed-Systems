from main import Main
import logging
import sys
import json
from block_tree import BlockTree
from proposal_message import ProposalMessage
from constants import *
from pacemaker import Pacemaker
from mem_pool import MemPool

class Node(process):
    def setup(node_id:int, nodes:set, nodesDict):
        self.main = Main(self.node_id)
        self.nodesDict = nodesDict
        self.block_tree = BlockTree([], [], None, None)
        self.pacemaker = Pacemaker(0, None, [], self.block_tree)
        self.mempool = MemPool([])
        output("[Node] [{}] Setup completed ".format(self.node_id))

    def run():
        output("[Node] [{}] Running Node".format(self.node_id))
        await(False)


    def receive(msg=("TXN", payload), from_= client):
        output("[Node] [{}] Received {} message:".format(self.node_id, TXN), " | Message: ", payload.to_string())
        self.process_new_round_event(None)

    def receive(msg=("PROPOSAL", proposal, sender_id), from_= sender):
        output("[Node] [{}] Received {} message from Node :".format(self.node_id, PROPOSAL), sender_id)
        self.process_proposal_msg(proposal, sender_id)


    def process_proposal_msg(proposal, sender_id):
        process_certificate_qc(proposal.block.qc)
        process_certificate_qc(proposal.high_commit_qc)
        self.pacemaker.advance_round_tc(proposal.last_round_tc)


    def process_new_round_event(last_tc):
        #TODO Get current Round
        if self.node_id == 0 and self.pacemaker.current_round == 0 :
            block = self.block_tree.generate_block(self.mempool.get_transactions(), self.pacemaker.current_round)
            proposal = ProposalMessage(block, last_tc, self.block_tree.high_commit_qc) 
            send(("PROPOSAL", proposal, self.node_id), to=nodes)