from main import Main
import logging
import sys
import json
from block_tree import BlockTree
from proposal_message import ProposalMessage
from constants import *
from pacemaker import Pacemaker

class Node(process):
    def setup(node_id:int, nodes:set, nodesDict):
        self.main = Main(self.node_id)
        self.nodesDict = nodesDict
        self.block_tree = BlockTree([], [], None, None)
        self.pacemaker = Pacemaker(0, None, [], self.block_tree)
        output("[Node] [{}] Setup completed ".format(self.node_id))

    def run():
        output("[Node] [{}] Running Node".format(self.node_id))
        await(False)


    def receive(msg=("TXN", payload), from_= client):
        output("[Node] [{}] Received {} message:".format(self.node_id, TXN), " | Message: ", payload.to_string())
        self.process_new_round_event(None)

    def receive(msg=("PROPOSAL", proposal, sender_id), from_= sender):
        output("[Node] [{}] Received {} message from Node :".format(self.node_id, PROPOSAL), sender_id)
    

    def start_event_processing(message):
        if(message.is_local_timeout_m()):
            #Pacemaker.local_timeout_round()
            pass
        elif(message.is_proposal_m()):
            self.process_proposal_msg(message)
        elif(message.is_vote_m()):
            self.process_vote_msg(message)
        elif(message.is_timeout_m()):
            self.process_timeout_message(message)
        else:
            pass


    def process_proposal_msg(message):
        pass

    def process_proposal_msg(message):
        pass


    def process_new_round_event(last_tc):
        #TODO Get current Round
        if self.node_id == 0 and self.pacemaker.current_round == 0 :
            block = self.block_tree.generate_block(None, 0)
            proposal = ProposalMessage(block, last_tc, self.block_tree.high_commit_qc) 
            send(("PROPOSAL", proposal, self.node_id), to=nodes)