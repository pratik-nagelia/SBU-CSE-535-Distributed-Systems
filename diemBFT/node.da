from main import Main
from block_tree import BlockTree
from proposal_message import ProposalMessage
from constants import *
from pacemaker import Pacemaker
from mem_pool import MemPool
from leader_election import LeaderElection
from safety import Safety
from ledger import Ledger

class Node(process):
    def setup(node_id: int, nodes: set, nodesDict):
        self.main = Main(self.node_id)
        self.nodesDict = nodesDict
        self.ledger = Ledger()
        self.block_tree = BlockTree([], [], None, None)
        self.safety = Safety(None, None, -1, -1)
        self.pacemaker = Pacemaker(0, None, [], self.block_tree)
        self.mempool = MemPool([])
        self.leader_election = LeaderElection(nodesDict, 10, 10, {})
        output("[Node] [{}] Setup completed ".format(self.node_id))

    def run():
        output("[Node] [{}] Running Node".format(self.node_id))
        # TODO HACK Couldnot init in the constructer
        self.block_tree.set_ledger(self.ledger)
        #self.block_tree.set_node_id(self.node_id)
        await(False)

    def receive(msg=("TXN", payload), from_=client):
        output("[Node] [{}] Received {} message:".format(self.node_id, TXN), " | Message: ", payload.to_string())
        self.process_new_round_event(None)

    def receive(msg=("PROPOSAL", proposal, sender_id), from_=sender):
        output("[Node] [{}] Received {} message from Node :".format(self.node_id, PROPOSAL), sender_id)
        self.process_proposal_msg(proposal, sender_id)

    def receive(msg=("VOTE", vote_msg, sender_id), from_=sender):
        output("[Node] [{}] Received {}  message".format(self.node_id, VOTE), "  from Node: [{}]".format(sender_id))
        self.process_vote_msg(vote_msg, sender_id)

    def process_proposal_msg(proposal, sender_id):
        print("[Node] [{}] Start processing the PROPOSAL proposal message".format(self.node_id))
        process_certificate_qc(proposal.block.qc)
        process_certificate_qc(proposal.high_commit_qc)
        self.pacemaker.advance_round_tc(proposal.last_round_tc)
        current_round = self.pacemaker.current_round
        leader = leader_election.get_leader(current_round)
        #leader = self.nodesDict[leader_obj]
        output("[Node] [{}]".format(self.node_id), " Current Round: [{}]".format(current_round)," Leader: [{}]".format(leader))
        output("[Node] [{}]".format(self.node_id), " proposal.block.round: [{}]".format(proposal.block.round)," sender_id: [{}]".format(sender_id), " proposal.block.author [{}]".format(proposal.block.author))
        if(proposal.block.round!=current_round or sender_id!=leader  or proposal.block.author!=leader):
            output("[Node] [{}]".format(self.node_id), " Reject current proposal sent by sender: [{}]".format(sender_id))
            return
        print("[Node] [{}] Add a new speculative state to the Ledger".format(self.node_id))
        #self.block_tree.execute_and_insert(proposal.block)
        #Test process_vote_msg
        vote_msg = None
        next_leader = leader_election.get_leader(current_round + 1)
        output("[Node] [{}]".format(self.node_id), " Send VOTE Message to next leader: [{}]".format(next_leader))
        send(("VOTE", vote_msg, self.node_id), to=self.nodesDict[next_leader])
        #vote_msg = self.safety.make_vote(proposal.block, proposal.last_round_tc)
        # if(vote_msg!=null):
        #     next_leader = leader_election.get_leader(current_round+1)
        #     send(("VOTE", vote_msg, self.node_id), to=next_leader)

    def process_vote_msg(vote_msg, sender_id):
        print("[Node] [{}] Start processing the VOTE message".format(self.node_id))
        qc = self.block_tree.process_vote(vote_msg)
        print("[Node] [{}] Check if a quorum has been formed".format(self.node_id))
        if(qc is not None):
            self.process_certificate_qc(qc)
            self.process_new_round_event(null)

    def process_certificate_qc(qc):
        pass

    def process_new_round_event(last_tc):
        # TODO Get current Round
        if self.node_id == 0 and self.pacemaker.current_round == 0:
            block = self.block_tree.generate_block(self.mempool.get_transactions(), self.pacemaker.current_round)
            proposal = ProposalMessage(block, last_tc, self.block_tree.high_commit_qc)
            send(("PROPOSAL", proposal, self.node_id), to=nodes)
