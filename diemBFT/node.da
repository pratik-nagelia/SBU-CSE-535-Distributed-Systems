from main import Main
from block_tree import BlockTree
from proposal_message import ProposalMessage
from pacemaker import Pacemaker
from mem_pool import MemPool
from leader_election import LeaderElection
from safety import Safety
from ledger import Ledger


class Node(process):
    def setup(node_id: int, nodes: set, nodesDict, conf, clientsDict):
        self.nodesDict = nodesDict
        self.ledger = Ledger(self.node_id, clientsDict)
        self.block_tree = BlockTree([], {}, None, None, self.nodesDict)
        self.safety = Safety(None, None, -1, -1, self.node_id, self.ledger, self.block_tree, self.nodesDict)
        self.pacemaker = Pacemaker(0, None, [], self.block_tree, self.node_id, conf['delta'])
        self.mempool = MemPool([], self.node_id)
        self.F = conf['F']
        self.leader_election = LeaderElection(nodesDict, 2*self.F+1,self.F, {}, self.pacemaker, self.ledger, self.node_id)
        print("[Node-{}] Setup completed ".format(self.node_id))


    def run():
        print("[Node-{}] Running Node".format(self.node_id))
        # TODO HACK Couldnot init in the constructer
        self.block_tree.set_ledger(self.ledger)
        self.block_tree.set_node_id(self.node_id)
        self.block_tree.F = self.F
        await False

    def receive(msg=("TXN", payload), from_=client):
        print("[Node-{}] Received {} message:".format(self.node_id, "TXN"), " | Message: ", payload.to_string())
        self.mempool.add_transaction(payload)
        pending_txn = self.mempool.get_transactions()
        if pending_txn is None:
            return
        self.process_new_round_event(None, pending_txn)

    def receive(msg=("PROPOSAL", proposal, sender_id), from_=sender):
        print("[Node-{}] Received {} message from Node :".format(self.node_id, "PROPOSAL"), sender_id)
        self.process_proposal_msg(proposal, sender_id)

    def receive(msg=("VOTE", vote_msg, sender_id), from_=sender):
        print("[Node-{}] Received {} message".format(self.node_id, "VOTE"), " from Node: [{}] for the proposal sent in block[{}]".format(sender_id, vote_msg.vote_info.id))
        self.process_vote_msg(vote_msg, sender_id)

    def receive(msg=("TRANSACTION_COMMITTED", payload), from_=node):
        print("TXXXXN Commite ================")
        # print("[CLIENT-{}]".format(self.client_id) +" Transaction committed successfully: {}".format(payload))

    def process_proposal_msg(proposal, sender_id):
        print("[Node-{}] Start processing the PROPOSAL proposal message".format(self.node_id))
        process_certificate_qc(proposal.block.qc)
        process_certificate_qc(proposal.high_commit_qc)
        self.pacemaker.advance_round_tc(proposal.last_round_tc)
        current_round = self.pacemaker.current_round
        leader = leader_election.get_leader(current_round)
        print("[Node-{}]".format(self.node_id), " Current Round: [{}]".format(current_round), " Leader: [{}]".format(leader))
        print("[Node-{}]".format(self.node_id), " proposal.block.round: [{}]".format(proposal.block.round), " sender_id: [{}]".format(sender_id), " proposal.block.author [{}]".format(proposal.block.author))
        if proposal.block.round != current_round or sender_id != leader or proposal.block.author != leader:
            print("[Node] [{}]".format(self.node_id), " Reject current proposal sent by sender: [{}]".format(sender_id))
            return
        #print("[Node] [{}] Add a new speculative state to the Ledger".format(self.node_id))
        self.block_tree.execute_and_insert(proposal.block)
        vote_msg = self.safety.make_vote(proposal.block, proposal.last_round_tc)
        if vote_msg is not None:
            vote_msg.sender = self.nodesDict[self.node_id]
            next_leader_id = leader_election.get_leader(current_round + 1)
            print("[Node-{}] Send the prepared VOTE to the next leader [{}] $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ ".format(self.node_id, next_leader_id))
            next_leader = self.nodesDict[next_leader_id]
            send(("VOTE", vote_msg, self.node_id), to=next_leader)

    def process_vote_msg(vote_msg, sender_id):
        print("[Node-{}] Start processing the VOTE message".format(self.node_id))
        qc = self.block_tree.process_vote(vote_msg, sender_id)
        #print("[Node-{}] Check if a quorum has been formed".format(self.node_id))
        if qc is not None:
            self.process_certificate_qc(qc)
            # if no pending transactions, dont process a new round evnt
            if self.ledger.get_pending_transactions(qc.vote_info.id) is None:
                 return
            self.process_new_round_event(None, None)

    def process_certificate_qc(qc):
        if qc is not None:
            committed_txn = self.block_tree.process_qc(qc)
            if committed_txn is not None: # and self.node_id == qc.author:
                client_id = committed_txn.fetch_client_id()
                print("[Node-{}] Notify client of committed transaction [{}] to client [{}]".format(self.node_id, committed_txn.to_string(), client_id))
                send(("TRANSACTION_COMMITTED", committed_txn.to_string()), to=self.clientsDict[client_id])

            # TODO Uncomment below
            self.leader_election.update_leaders(qc)
            self.pacemaker.advance_round_qc(qc)

    def process_new_round_event(last_tc, transaction):
        if self.node_id == self.leader_election.get_leader(self.pacemaker.current_round):
            print("[Node-{}] Processing New Round Event as the leader".format(self.node_id))
            block = self.block_tree.generate_block(transaction, self.pacemaker.current_round)
            proposal = ProposalMessage(block, last_tc, self.block_tree.high_commit_qc)
            print("[Node-{}] Send PROPOSAL message to the remaining node ****************************************************************************************************************************************************".format(self.node_id))
            send(("PROPOSAL", proposal, self.node_id), to=nodes)
