
class Safety(process):
    def setup(private_key:str, public_keys:list, highest_vote_round:int, highest_qc_round: int):
        self.private_key = private_key
        self.public_keys = public_keys
        self.highest_vote_round = highest_vote_round
        self.highest_qc_round = highest_qc_round

    def increase_highest_vote_round(round):
        highest_vote_round = max(round,highest_vote_round)

    def update_highest_qc_round(qc_round):
        highest_qc_round = max(qc_round, highest_qc_round)

    def consecutive(block_round,round):
        return round+1==block_round

    def safe_to_extend(block_round, qc_round, tc):
        return consecutive(block_round, tc.round) and qc_round >= max(tc.timeout_high_qc_rounds)

    def safe_to_vote(block_round, qc_round, tc):
        if block_round <= max(highest_vote_round,qc_round):
            return False
        return consecutive(block_round, qc_round) or safe_to_extend(block_round, qc_round, tc)

    def safe_to_timeout(_round,qc_round,tc):
        if qc_round < highest_qc_round or _round <= max(highest_vote_round-1, qc_round):
            return False
        return consecutive(_round, qc_round) or consecutive(_round, tc.round)

    def commit_state_id_candidate(block_round, qc):
        if consecutive(block_round, qc.vote_info._round):
            return Ledger.pending_state(qc.author)
        return None
