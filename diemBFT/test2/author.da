import mempool as mp
import main as mainmodule
from constants import *
import block as bl
import proposalMessage as propMsg

config(channel is fifo, clock is lamport)
class Author(process):
    def setup(validators:set, otherValidators:set, num:int, authorMap):
        self.n = len(validators)
        self.num = num
        self.memPool = mp.MemPool()
        self.main = mainmodule.Main(num)

    def getNum():
        return num

    def receive(msg= (PROPOSAL, message, sender, senderId)):
        log('Received proposal message from proposer - ' + str(senderId))
        status = self.main.processProposalMessage(message)
        newLeader = self.authorMap[(senderId + 1) % self.n]
        if status:
            # Send a +ve message to the new leader
            send((VOTE, True, num), to= newLeader)
        else:
            # Send a -ve message to the new leader
            send((VOTE, False, num), to= newLeader)
        log('Vote sent to new leader')

    def receive(msg= (VOTE, result, senderId)):
        log('Received vote message from - ' + str(senderId))
        log('Result received - ' + str(result))

    def receive(msg= (TXN, payload)):
        self.memPool.addTransaction(payload)
        log('Added transaction to mempool')

        # TODO: Hardcoded initial leader to 0
        if num == 0 and self.main.pacemaker.getCurrentRound() == 0:
            log('num == 0 and self.main.pacemaker.getCurrentRound() == 0')
            proposalMessage = createProposalMessage(payload)
            log('Created proposal message - ' + str(proposalMessage))
            send((PROPOSAL, proposalMessage, self, num), to= validators)
            log('Sent proposal message to all validators')

    def createProposalMessage(payload):
        block = bl.Block(self.main.pacemaker.getCurrentRound(), self, payload)
        pm = propMsg.ProposalMessage(block)
        return pm

    def run():
        log('Author started')
        await(False)

    def log(msg):
        prefix = '[AUTHOR-' + str(num) + '] '
        output(prefix + msg)