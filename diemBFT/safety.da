from vote_info import VoteInfo
from vote_message import VoteMsg


class Safety:
    F = 1

    def __init__(self, private_key, public_key, highest_vote_round, highest_qc_round,node_id):
        self.private_key = private_key
        self.public_key = public_key
        self.highest_vote_round = highest_vote_round
        self.highest_qc_round = highest_qc_round
        self.node_id =  node_id

    def increase_highest_vote_round(self, voting_round):
         self.highest_vote_round = max(self.highest_vote_round,voting_round)
    #
    def update_highest_qc_round(self, qc_round):
        self.highest_qc_round = max(self.highest_qc_round,qc_round)
    #
    def consecutive(self, block_round, voting_round):
        if(block_round == voting_round+1):
            print("[SAFETY-Node-{}".format(self.node_id),"] The current block was proposed just after the last QC or TC round.")
            return True
        return False
    #
    def safe_to_extend(self, block_round, qc_round, timeout_certificate):
        return self.consecutive(block_round, timeout_certificate.round)
    #
    def safe_to_vote(self, block_round, qc_round, timeout_certificate):
        print("[SAFETY-Node-{}".format(self.node_id),"] Check if it's SAFE TO VOTE for the current proposal")
        if(block_round <= max(self.highest_vote_round, qc_round)):
             return False
        print("[SAFETY-Node-{}".format(self.node_id), "] safe_to_vote. The received block was proposed in a round after the last voting or quorum round in which I participated")
        return self.consecutive(block_round, qc_round) or self.safe_to_extend(block_round, qc_round, timeout_certificate)
    #
    # def safe_to_timeout(self, voting_round, qc_round, timeout_certificate):
    #     if(qc_round < self.highest_qc_round or voting_round <= max(self.highest_vote_round-1, qc_round)):
    #         return False
    #     return self.consecutive(voting_round, qc_round) or self.consecutive(voting_round, timeout_certificate.round)
    #
    # #TODO
    # def commit_state_id_candidate(self, block_round, quorum_certificate):
    #     if(self.consecutive(block_round,quorum_certificate.vote_info.round)):
    #         return Ledger.pending_state(quorum_certificate.id) #Confirm quorum_certificate.id
    #     return -1

    # TODO
    def valid_signature(self, block, timeout_certificate):
        return True

    def make_vote(self, block, last_round_tc):
        print("[SAFETY-Node-{}".format(self.node_id),"] Make VOTE for the current proposal")
        qc_round = -1 # No QC until now. #TODO Confirm if it can be set to -1.
        if(block.qc is not None):
            qc_round = block.qc.vote_info.round #Confirm which round it is. Check after creation of a QC.

        if self.valid_signature(block, last_round_tc) and self.safe_to_vote(block.round, qc_round, last_round_tc):
            print("[SAFETY-Node-{}".format(self.node_id), "] HURRAYY! GREEN SIGNAL RECEIVED. It is SAFE for me to VOTE for the curr proposal now. Let's prepare a VOTE message now")
            self.update_highest_qc_round(qc_round)
            self.increase_highest_vote_round(block.round)

            #vote_info = VoteInfo(block.id, block.round, block.quorum_certificate.vote_info.id, qc_round,
                                 #     #Ledger.pendingState(block.id)) => Last function needs to be implemented
        #
        #     #VoteInfo vote_info = VoteInfo(block.id, block.round, block.quorum_certificate.vote_info.id, qc_round,
        #     #Ledger.pendingState(block.id)) => Last function needs to be implemented
        #
        #     #Needs revisiting
        #     #CommitStateIdCandidate candidate = CommitStateIdCandidate(block.round, block.quorum_certificate)
        #     #LedgerCommitInfo ledger_commit_info = LedgerCommitInfo(candidate, calculate_hash(vote_info))
        #
        #     #BlockTree Check how block_tree's object will be initialized.
        #     #VoteMsg msg = VoteMsg(vote_info, ledger_commit_info, BlockTree.high_commit_qc) #=> Confirm last parameter
        #     return msg
        vote_info = VoteInfo(0, 0, 0, 0, 0)
        return VoteMsg(vote_info, None, None, None, None)

    # #TODO
    # def calculate_hash(self, vote_info):
    #     return None
    #

    #
    # def make_timeout(self, voting_round, highest_quorum_certificate, last_timeout_tc):
    #     qc_round = highest_quorum_certificate.vote_info.round
    #     if(self.valid_signature(highest_quorum_certificate, last_timeout_tc) and self.safe_to_timeout(voting_round, qc_round, last_timeout_tc)):
    #         increase_highest_vote_round(voting_round)
    #         return TimeoutInfo(voting_round, highest_quorum_certificate)
    #     return None
