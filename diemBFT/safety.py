# -*- generated by 1.0.14 -*-
import da
_config_object = {}
VoteInfo = da.import_da('vote_info')
VoteMsg = da.import_da('vote_message')
LedgerCommitInfo = da.import_da('ledger_commit_info')
Ledger = da.import_da('ledger')

class Safety():
    F = 1

    def __init__(self, private_key, public_key, highest_vote_round, highest_qc_round, node_id, ledger, block_tree):
        self.private_key = private_key
        self.public_key = public_key
        self.highest_vote_round = highest_vote_round
        self.highest_qc_round = highest_qc_round
        self.node_id = node_id
        self.ledger = ledger
        self.block_tree = block_tree

    def increase_highest_vote_round(self, voting_round):
        self.highest_vote_round = max(self.highest_vote_round, voting_round)

    def update_highest_qc_round(self, qc_round):
        self.highest_qc_round = max(self.highest_qc_round, qc_round)

    def consecutive(self, block_round, voting_round):
        if (block_round == (voting_round + 1)):
            print('[SAFETY-Node-{}'.format(self.node_id), '] The current block was proposed just after the last QC or TC round.')
            return True
        return False

    def safe_to_extend(self, block_round, qc_round, timeout_certificate):
        return self.consecutive(block_round, timeout_certificate.round)

    def safe_to_vote(self, block_round, qc_round, timeout_certificate):
        print('[SAFETY-Node-{}'.format(self.node_id), "] Check if it's SAFE TO VOTE for the current proposal")
        if (block_round <= max(self.highest_vote_round, qc_round)):
            return False
        print('[SAFETY-Node-{}'.format(self.node_id), '] safe_to_vote. The received block was proposed in a round after the last voting or quorum round in which I participated')
        return (self.consecutive(block_round, qc_round) or self.safe_to_extend(block_round, qc_round, timeout_certificate))

    def valid_signature(self, block, timeout_certificate):
        return True

    def commit_state_id_candidate(self, block_round, block_qc):
        return 0

    def make_vote(self, block, last_round_tc):
        print('[SAFETY-Node-{}'.format(self.node_id), '] Make VOTE for the current proposal')
        qc_round = (- 1)
        if (not (block.qc is None)):
            qc_round = block.qc.vote_info.round
        if (self.valid_signature(block, last_round_tc) and self.safe_to_vote(block.round, qc_round, last_round_tc)):
            print('[SAFETY-Node-{}'.format(self.node_id), "] HURRAYY! GREEN SIGNAL RECEIVED. It is SAFE for me to VOTE for the curr proposal now. Let's prepare a VOTE message now")
            self.update_highest_qc_round(qc_round)
            self.increase_highest_vote_round(block.round)
            block_qc_vote_info_id = (- 1)
            if (not (block.qc is None)):
                block_qc_vote_info_id = block.qc.vote_info.id
            vote_info = VoteInfo.VoteInfo(block.block_id, block.round, block_qc_vote_info_id, qc_round, self.ledger.pending_state(block.block_id))
            commit_state_id = self.commit_state_id_candidate(block.round, block.qc)
            ledger_commit_info = LedgerCommitInfo.LedgerCommitInfo(commit_state_id, hash(vote_info))
            msg = VoteMsg.VoteMsg(vote_info, ledger_commit_info, self.block_tree.high_commit_qc, None, None)
            return msg
        return None
