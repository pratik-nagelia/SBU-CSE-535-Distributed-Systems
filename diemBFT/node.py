# -*- generated by 1.0.14 -*-
import da
PatternExpr_359 = da.pat.TuplePattern([da.pat.ConstantPattern('TXN'), da.pat.FreePattern('payload')])
PatternExpr_366 = da.pat.FreePattern('client')
PatternExpr_398 = da.pat.TuplePattern([da.pat.ConstantPattern('PROPOSAL'), da.pat.FreePattern('proposal'), da.pat.FreePattern('sender_id')])
PatternExpr_407 = da.pat.FreePattern('sender')
PatternExpr_428 = da.pat.TuplePattern([da.pat.ConstantPattern('VOTE'), da.pat.FreePattern('vote_msg'), da.pat.FreePattern('sender_id')])
PatternExpr_437 = da.pat.FreePattern('sender')
_config_object = {}
Main = da.import_da('main')
BlockTree = da.import_da('block_tree')
ProposalMessage = da.import_da('proposal_message')
Pacemaker = da.import_da('pacemaker')
MemPool = da.import_da('mem_pool')
LeaderElection = da.import_da('leader_election')
Safety = da.import_da('safety')
Ledger = da.import_da('ledger')

class Node(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_NodeReceivedEvent_0', PatternExpr_359, sources=[PatternExpr_366], destinations=None, timestamps=None, record_history=None, handlers=[self._Node_handler_358]), da.pat.EventPattern(da.pat.ReceivedEvent, '_NodeReceivedEvent_1', PatternExpr_398, sources=[PatternExpr_407], destinations=None, timestamps=None, record_history=None, handlers=[self._Node_handler_397]), da.pat.EventPattern(da.pat.ReceivedEvent, '_NodeReceivedEvent_2', PatternExpr_428, sources=[PatternExpr_437], destinations=None, timestamps=None, record_history=None, handlers=[self._Node_handler_427])])

    def setup(self, node_id, nodes, nodesDict, **rest_780):
        super().setup(node_id=node_id, nodes=nodes, nodesDict=nodesDict, **rest_780)
        self._state.node_id = node_id
        self._state.nodes = nodes
        self._state.nodesDict = nodesDict
        self.output('[Node] [{}] Setup Started'.format(self._state.node_id))
        self._state.main = Main.Main(self._state.node_id)
        self._state.nodesDict = self._state.nodesDict
        self._state.ledger = Ledger.Ledger()
        self._state.block_tree = BlockTree.BlockTree([], {}, None, None)
        self._state.safety = Safety.Safety(None, None, (- 1), (- 1), self._state.node_id, self._state.ledger, self._state.block_tree)
        self._state.pacemaker = Pacemaker.Pacemaker(0, None, [], self._state.block_tree)
        self._state.mempool = MemPool.MemPool([], self._state.node_id)
        self._state.leader_election = LeaderElection.LeaderElection(self._state.nodesDict, 10, 10, {}, self._state.pacemaker, self._state.ledger)
        self.output('[Node] [{}] Setup completed '.format(self._state.node_id))

    def run(self):
        self.output('[Node] [{}] Running Node'.format(self._state.node_id))
        self._state.block_tree.set_ledger(self._state.ledger)
        self._state.block_tree.set_node_id(self._state.node_id)
        super()._label('_st_label_354', block=False)
        _st_label_354 = 0
        while (_st_label_354 == 0):
            _st_label_354 += 1
            if False:
                _st_label_354 += 1
            else:
                super()._label('_st_label_354', block=True)
                _st_label_354 -= 1

    def process_proposal_msg(self, proposal, sender_id):
        print('[Node] [{}] Start processing the PROPOSAL proposal message'.format(self._state.node_id))
        self.process_certificate_qc(proposal.block.qc)
        self.process_certificate_qc(proposal.high_commit_qc)
        self._state.pacemaker.advance_round_tc(proposal.last_round_tc)
        current_round = self._state.pacemaker.current_round
        leader = self._state.leader_election.get_leader(current_round)
        self.output('[Node] [{}]'.format(self._state.node_id), ' Current Round: [{}]'.format(current_round), ' Leader: [{}]'.format(leader))
        self.output('[Node] [{}]'.format(self._state.node_id), ' proposal.block.round: [{}]'.format(proposal.block.round), ' sender_id: [{}]'.format(sender_id), ' proposal.block.author [{}]'.format(proposal.block.author))
        if ((not (proposal.block.round == current_round)) or (not (sender_id == leader)) or (not (proposal.block.author == leader))):
            self.output('[Node] [{}]'.format(self._state.node_id), ' Reject current proposal sent by sender: [{}]'.format(sender_id))
            return
        print('[Node] [{}] Add a new speculative state to the Ledger'.format(self._state.node_id))
        self._state.block_tree.execute_and_insert(proposal.block)
        vote_msg = self._state.safety.make_vote(proposal.block, proposal.last_round_tc)
        if (not (vote_msg is None)):
            vote_msg.sender = self._state.nodesDict[self._state.node_id]
            next_leader_id = self._state.leader_election.get_leader((current_round + 1))
            self.output('Next leader : ', next_leader_id)
            next_leader = self._state.nodesDict[next_leader_id]
            self.send(('VOTE', vote_msg, self._state.node_id), to=next_leader)

    def process_vote_msg(self, vote_msg, sender_id):
        print('[Node] [{}] Start processing the VOTE message'.format(self._state.node_id))
        qc = self._state.block_tree.process_vote(vote_msg)
        print('[Node] [{}] Check if a quorum has been formed'.format(self._state.node_id))
        if (not (qc is None)):
            self.process_certificate_qc(qc)
            self.process_new_round_event(None)

    def process_certificate_qc(self, qc):
        print('[Node] [{}] Process Certificate'.format(self._state.node_id))
        self._state.block_tree.process_qc(qc)
        self._state.leader_election.update_leaders(qc)
        self._state.pacemaker.advance_round_qc(qc)

    def process_new_round_event(self, last_tc):
        if ((self._state.node_id == 0) and (self._state.pacemaker.current_round == 0)):
            block = self._state.block_tree.generate_block(self._state.mempool.get_transactions(), self._state.pacemaker.current_round)
            proposal = ProposalMessage.ProposalMessage(block, last_tc, self._state.block_tree.high_commit_qc)
            self.send(('PROPOSAL', proposal, self._state.node_id), to=self._state.nodes)

    def _Node_handler_358(self, payload, client):
        self.output('[Node] [{}] Received {} message:'.format(self._state.node_id, 'TXN'), ' | Message: ', payload.to_string())
        self._state.mempool.add_transaction(payload.to_string())
        self.process_new_round_event(None)
    _Node_handler_358._labels = None
    _Node_handler_358._notlabels = None

    def _Node_handler_397(self, proposal, sender_id, sender):
        self.output('[Node] [{}] Received {} message from Node :'.format(self._state.node_id, 'PROPOSAL'), sender_id)
        self.process_proposal_msg(proposal, sender_id)
    _Node_handler_397._labels = None
    _Node_handler_397._notlabels = None

    def _Node_handler_427(self, vote_msg, sender_id, sender):
        self.output('[Node] [{}] Received {}  message'.format(self._state.node_id, 'VOTE'), '  from Node: [{}]'.format(sender_id))
        self.process_vote_msg(vote_msg, sender_id)
    _Node_handler_427._labels = None
    _Node_handler_427._notlabels = None
