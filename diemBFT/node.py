# -*- generated by 1.0.14 -*-
import da
PatternExpr_240 = da.pat.FreePattern('txn')
PatternExpr_244 = da.pat.FreePattern('client')
PatternExpr_266 = da.pat.TuplePattern([da.pat.ConstantPattern('test'), da.pat.FreePattern('proposal')])
PatternExpr_273 = da.pat.FreePattern('node')
_config_object = {}
import logging
import sys
import json
Main = da.import_da('main')
BlockTree = da.import_da('block_tree')
ProposalMessage = da.import_da('proposal_message')

class Node(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_NodeReceivedEvent_0', PatternExpr_240, sources=[PatternExpr_244], destinations=None, timestamps=None, record_history=None, handlers=[self._Node_handler_239]), da.pat.EventPattern(da.pat.ReceivedEvent, '_NodeReceivedEvent_1', PatternExpr_266, sources=[PatternExpr_273], destinations=None, timestamps=None, record_history=None, handlers=[self._Node_handler_265])])

    def setup(self, node_id, nodes, nodesDict, **rest_372):
        super().setup(node_id=node_id, nodes=nodes, nodesDict=nodesDict, **rest_372)
        self._state.node_id = node_id
        self._state.nodes = nodes
        self._state.nodesDict = nodesDict
        self._state.main = Main(self._state.node_id)
        self._state.nodesDict = self._state.nodesDict
        self._state.block_tree = BlockTree([], [], None, None)
        self.output('Setup complete for Node : ', self._state.node_id)

    def run(self):
        self.output('Running Node : ', str(self._state.node_id))
        super()._label('_st_label_235', block=False)
        _st_label_235 = 0
        while (_st_label_235 == 0):
            _st_label_235 += 1
            if False:
                _st_label_235 += 1
            else:
                super()._label('_st_label_235', block=True)
                _st_label_235 -= 1

    def start_event_processing(self, message):
        if message.is_local_timeout_m():
            pass
        elif message.is_proposal_m():
            self.process_proposal_msg(message)
        elif message.is_vote_m():
            self.process_vote_msg(message)
        elif message.is_timeout_m():
            self.process_timeout_message(message)
        else:
            pass

    def process_proposal_msg(self, message):
        pass

    def process_vote_msg(self, message):
        pass

    def process_timeout_message(self, message):
        pass

    def process_new_round_event(self, last_tc):
        if (self._state.node_id == 0):
            block = self._state.block_tree.generate_block(None, 0)
            proposal = ProposalMessage(block, last_tc, self._state.block_tree.high_commit_qc)
            print(str(proposal))
            self.send(('test', proposal), to=self._state.nodes)

    def _Node_handler_239(self, txn, client):
        self.output('[NODE] Received in node :', self._state.node_id, ' | Message: ', txn.to_string(), '| Client Id :', client)
        self.process_new_round_event(None)
    _Node_handler_239._labels = None
    _Node_handler_239._notlabels = None

    def _Node_handler_265(self, proposal, node):
        print('Chutttttiiii')
    _Node_handler_265._labels = None
    _Node_handler_265._notlabels = None
