import datetime


class MemPool:

    def __init__(self, transactions, node_id, node_specific_file, common_logging):
        self.deduplication_set = set()
        self.pending_transactions = []
        self.in_process_transactions = []
        self.committed_transactions = []
        self.transactions = transactions
        self.node_id = node_id
        self.node_specific_file = node_specific_file
        self.common_logging = common_logging
        self.transaction_status = {}

    def output_to_files(self, string_msg):
        msg = str(datetime.datetime.now()) + " " + string_msg
        self.common_logging.write("\n")
        self.node_specific_file.write("\n")
        self.node_specific_file.write(msg)
        self.common_logging.write(msg)
        self.common_logging.write("\n")
        self.node_specific_file.write("\n")
        self.node_specific_file.flush()
        self.common_logging.flush()
        print(msg)

    def get_transactions(self):
        if len(self.pending_transactions)==0:
            return None
        pending_txn = self.pending_transactions.pop(0)
        not_pending_txn = ['IN_PROGRESS', 'COMMITTED']
        while len(self.pending_transactions)>0 and pending_txn is not None and self.get_transaction_status not in not_pending_txn:
            pending_txn = self.pending_transactions.pop(0)

        if pending_txn is None:
            return None
        self.output_to_files("[MEMPOOL-Node-{}] Get a pending transaction for proposing: {}".format(self.node_id, pending_txn.to_string()))
        #self.in_process_transactions.append(pending_txn)

        self.update_transaction_status(pending_txn, 'IN_PROGRESS')
        #hash_txn = hash(pending_txn.to_string())
        #self.transaction_status[hash_txn] = 'IN_PROGRESS'
        return pending_txn

    def has_pending_transactions(self):
        size = len(self.pending_transactions)
        self.output_to_files("[MEMPOOL-Node-{}] PENDING Transaction Size: {}".format(self.node_id, size))
        if size > 0:
            return True
        return False

    def add_transaction(self, transaction):
        hash_txn = hash(transaction.to_string())
        status = self.get_transaction_status(transaction)
        if hash_txn in self.deduplication_set or status is not "NEW_TRANSACTION":
            self.output_to_files("[MEMPOOL-Node-{}] DUPLICATE Transaction: {}".format(self.node_id, transaction.to_string))
            return
        self.deduplication_set.add(hash_txn)
        self.pending_transactions.append(transaction)
        self.update_transaction_status(transaction, "PENDING") #self.transaction_status[hash_txn] = 'PENDING'
        self.output_to_files("[MEMPOOL-Node-{}] Transaction added to the pending queue: {}".format(self.node_id, transaction.to_string()))

    '''def commit_transaction(self, transaction):
        hash_txn = hash(transaction.to_string())
        self.transaction_status[hash_txn] = 'COMMITTED'''''

    def update_transaction_status(self, transaction, new_status):
        if transaction is None:
            return
        self.output_to_files("[MEMPOOL-Node-{}] Update Status of TXN: {} to {}".format(self.node_id, transaction.to_string(), new_status))
        hash_txn = hash(transaction.to_string())
        self.transaction_status[hash_txn] = new_status

    def get_transaction_status(self, transaction):
        if transaction is None:
            return "IGNORE"
        hash_txn = hash(transaction.to_string())
        if hash_txn not in self.transaction_status:
            return "NEW_TRANSACTION"
        return self.transaction_status[hash_txn]

    def check_txn_status(self, transaction):
        hash_txn = hash(transaction.to_string())
        if self.transaction_status[hash_txn] is 'COMMITTED':
            return True
        return False

    def if_committed_or_not(self, transaction):
        status = self.get_transaction_status(transaction)
        if status is "COMMITTED":
            return True
        return False

