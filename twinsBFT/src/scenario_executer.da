import os
import shutil
import sys
import json
import datetime

sys.path.append('../config')

from client import Client
from config import configs
from cryptography import Cryptography
from validator import ValidatorFI
from network_playground import NetworkPlayground
import itertools


class RunDiemBFT(process):

    def setup(test_scenarios, config, config_id):
        self.all_nodes = test_scenarios["all_nodes"]
        self.honest_nodes = test_scenarios["honest_nodes"]
        self.faulty_nodes = test_scenarios["faulty_nodes"]
        self.round_arrangements = test_scenarios["round_arrangements"]
        self.enable_partitions = test_scenarios["enable_partitions"]
        self.nclients = int(config['nclients'])
        self.liveness_bound = test_scenarios["liveness_bound"]
        os.makedirs('../logs/config' + str(config_id))
        os.makedirs('../ledgers/config' + str(config_id))
        os.makedirs('../reports/config' + str(config_id))
        filename = '../reports/config' + str(config_id) + '/' + "scenario_executer.log"
        self.log_file = open(filename, 'a+')
        self.await_liveness_prop_check = False
        self.liveness_check = False
        self.playground = new(NetworkPlayground)
    
    def run():

        private_keys_validators = {}
        public_keys_validators = {}
        private_keys_clients = {}
        public_keys_clients = {}

        validators = new(ValidatorFI, num=len(all_nodes))
        clients = new(Client, num=nclients)
        #playground =

        nodes_mapping = {}
        nodes_reverse = {}
        for (node_id, v) in zip(all_nodes, validators):
            nodes_mapping[node_id] = v
            nodes_reverse[v] = node_id

        for id in (honest_nodes + faulty_nodes):
            private_key, public_key = Cryptography.generate_key()
            private_keys_validators[nodes_mapping[id]] = private_key
            public_keys_validators[nodes_mapping[id]] = public_key

        for id in faulty_nodes:
            # private_key, public_key = Cryptography.generate_key()
            private_keys_validators[nodes_mapping[-1 * id]] = private_keys_validators[nodes_mapping[id]]
            public_keys_validators[nodes_mapping[-1 * id]] = public_keys_validators[nodes_mapping[id]]

        for c in clients:
            private_key, public_key = Cryptography.generate_key()
            private_keys_clients[c] = private_key
            public_keys_clients[c] = public_key

        print("Nodes Mapping : " + str(nodes_mapping))
        print("Reverse Node Mapping : " + str(nodes_reverse))
        print("Private Keys : " + str(private_keys_validators))
        print("Public Keys : " + str(public_keys_validators))

        leader_map = {}
        for key in self.round_arrangements:
            leader_map[int(key)] = round_arrangements[key]["leader"]
        print("Leader Map  =>" + str(leader_map))

        for v in validators:
            node_id = nodes_reverse[v]
            if node_id < 0:
                node_id = node_id * -1
            setup({v}, (config, config_id, node_id, list(validators), list(clients),
                        private_keys_validators[v], public_keys_validators, public_keys_clients, self.playground, leader_map, nodes_mapping, nodes_reverse[v]))

        for i, c in enumerate(clients):
            setup({c}, (config, config_id, i, list(validators), private_keys_clients[c], public_keys_validators))

        setup(self.playground, (config_id, self.enable_partitions, round_arrangements, nodes_mapping, nodes_reverse, self.liveness_bound))
        start(self.playground, ())

        start(validators)
        start(clients)

        await(each(c in clients, has=received(('Done',), from_=c)))
        output("All clients done, informing all validators.", config_id)
        send(('Done',), to=validators)

        safety_ensured = check_safety(all_nodes)
        if (safety_ensured):
            log_to_file("Safety Check Passed")
        else:
            log_to_file("Safety Check Failed")

        liveness = liveness_check_fun()
        if (liveness):
            log_to_file("Liveness Check Passed")
        else:
            log_to_file("Liveness Check Failed")

    def liveness_check_fun():
        send(('CHECK_LIVENESS',), to=self.playground)
        await(self.await_liveness_prop_check)
        return self.liveness_check
    
    def receive(msg=('CHECK_LIVENESS', prop_ans), from_=sender):
        self.liveness_check = prop_ans
        self.await_liveness_prop_check = True
        
    def log_to_file(string_msg):
        msg = str(datetime.datetime.now()) + " " + string_msg
        self.log_file.write("\n")
        self.log_file.write(msg)
        self.log_file.write("\n")
        self.log_file.flush()
        print(msg)

    def check_safety(all_nodes):
        file_map = []
        safety = True
        # Open all ledger files
        for id in all_nodes:
            filename = "validator_" + str(id) + ".ledger"
            fp = open('../ledgers/config' + str(config_id) + "/" + filename, 'r')
            file_map.append(fp)
        count = 0
        txn = ""
        while count < len(file_map):
            first = True
            for file in file_map:
                line_read = file.readline()
                if not line_read:
                    count += 1
                    continue
                line_read = line_read.strip()
                if first:
                    txn = line_read
                    first = False
                if line_read != txn:
                    safety = False
                    break
        return safety

def is_config_valid(config):
    if int(config['nvalidators']) < (3 * int(config['nfaulty']) + 1):
        print(
            "Number of validators should be more than thrice of number of faulty validators.")
        return False
    if (int(config['nfaulty']) > int(config['exclude_size'])) or (int(config['exclude_size']) > 2 * int(config['nfaulty'])):
        print("Exlude size should be between nfaulty and 2 * nfaulty")
        return False
    return True


def main():

    if os.path.exists('../logs/') and os.path.isdir('../logs/'):
        shutil.rmtree('../logs/')

    if os.path.exists('../ledgers/') and os.path.isdir('../ledgers/'):
        shutil.rmtree('../ledgers/')

    if os.path.exists('../reports/') and os.path.isdir('../reports/'):
        shutil.rmtree('../reports/')

    config_id = 0
    config = configs[0]
    if not is_config_valid(config):
        output("The provided config", config, "is not valid. Skipping this config.")
        return
    with open(sys.argv[1]) as test_scenarios_file:
        test_scenarios = json.load(test_scenarios_file)
    run = new(RunDiemBFT)
    setup(run, (test_scenarios, config, config_id))
    start(run)

