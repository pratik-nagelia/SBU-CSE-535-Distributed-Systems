from message import Message
from partition_view import PartitionView
import datetime
from playground_message import Playground_Message
import threading

class NetworkPlayground(process):
    def setup(config_id, enable_partitions, partition_arrangement, nodes_mapping, nodes_reverse, liveness_bound):
        filename = '../logs/config' + str(config_id) + '/' + "network_playground.log"
        self.log_file = open(filename, 'a+')
        self.received_sufficient_responses = set()
        self.message_id = 0
        self.pending_message_acks = {}
        self.playground_exited = False
        self.liveness_bound = liveness_bound
        self.last_commit_round = 0

    def run():
        print("Starting Network Playground")
        await (len(received_sufficient_responses) == len(nodes_mapping.keys()))
        self.playground_exited = True
        print("Network Playground Exiting !!")

    def receive(msg=('COMMIT_INFO', commit_round), from_=sender):
        self.last_commit_round = max(self.last_commit_round, commit_round)
        log_to_file("[Network-Playground] Update last commit round to {}".format(self.last_commit_round))

    def receive(msg=('Done',), from_=sender):
        received_sufficient_responses.add(nodes_reverse[sender])

    def log_to_file(string_msg):
        msg = str(datetime.datetime.now()) + " " + string_msg
        self.log_file.write("\n")
        self.log_file.write(msg)
        self.log_file.write("\n")
        self.log_file.flush()
        print(msg)

    def intra_partition_drop(message):
        partition_view = partition_arrangement[str(message.round)]
        if (partition_view["is_intra_partition_drop"] == True) \
                and (partition_view["intra_partition_drop_message_type"] == message.message_type) \
                and partition_view["intra_partition_drop_message_from"] == message.source:
            return True
        else:
            return False

    def filter(message):
        return intra_partition_drop(message)

    def find_nodes_in_partition(partition_sets, source):
        for partition in partition_sets:
            if source in partition:
                return partition
        return []

    def get_partition_of_sender(round, validator_id):
        partition_view = partition_arrangement[str(round)]['partition_set']
        for partition_set in partition_view:
            if validator_id in partition_set:
                log_to_file(
                    "[Network-Playground] Partition Set of validator {}: {}. Current partition view: {}".format(
                        str(validator_id), str(partition_set), str(partition_view)))
                return partition_set

    def create_playground_message(messsage, sender, destination):
        self.message_id += 1
        p_message = Playground_Message(self.message_id, messsage, sender, destination)
        return p_message

    def receive(msg=('ACK', message_id), from_=sender):
        self.pending_message_acks[message_id]=True
        print("[Network-Playground]Received an ACK for message with id: {} {}".format(str(message_id), self.pending_message_acks[message_id]))

    # noinspection Pylint
    def receive(msg=('Unicast', message), from_=sender):
        log_to_file("[Network-Playground] UNICAST message received : " + str(message))
        round = message.round

        #Check liveness property
        if self.last_commit_round+self.liveness_bound<round:
            log_to_file("[Network-Playground] Liveness Property Violated!!~~~~~~~~~~~~~~~~~~~~~")
    
        if filter(message): 
            return

        
        leader = message.destination

        sender_id = nodes_reverse[sender]
        target = []
        
        if enable_partitions:
            partition_set = get_partition_of_sender(round, sender_id)
            if leader in partition_set:
                log_to_file(
                    "[Network-Playground] Both the Leader and Sender belong to the same partition. Forward the message to the leader...")
                target.append(nodes_mapping[leader])
            if (leader * -1) in partition_set:
                target.append(nodes_mapping[(leader * -1)])
        else:
            target.append(nodes_mapping[leader])
            if (leader * -1) in nodes_mapping:
                target.append(nodes_mapping[(leader * -1)])

        log_to_file(
            "[Network-Playground] Unicast Sending message to : " + str([nodes_reverse[node] for node in target]))
        send_message(message, sender, target, False)

    def receive(msg=('Broadcast', message), from_=sender):
        log_to_file("[Network-Playground] BROADCAST message received : {}. Sender: {} ".format(str(message), sender))

        round = message.round
        # Check liveness property
        if self.last_commit_round + self.liveness_bound < round:
            log_to_file("[Network-Playground] Liveness Property Violated!!~~~~~~~~~~~~~~~~~~~~~")

        if filter(message): 
            return

        if enable_partitions:
            partition_set = get_partition_of_sender(message.round, message.source)
            target = [nodes_mapping[i] for i in partition_set]
            dropped_nodes = set(nodes_mapping.keys()) - set(partition_set)
            log_to_file("Message would be delivered to nodes: {}. Leaving nodes: {}".format(str(partition_set), str(dropped_nodes)))
            send_message(message, sender, target, True)
        else:
            log_to_file("Message would be delivered to all nodes: {}.".format(str(nodes_mapping.values())))
            send_message(message, sender, nodes_mapping.values(), True)

    def send_message(message, sender, destination, list_b):
        if list_b is True:
            for destination_node in destination:
                p_message = create_playground_message(message, sender, destination_node)
                self.pending_message_acks[p_message.id]=False
                log_to_file("[Network-Playground] Send_Message  {}.".format(str(destination_node)))
                send((message.message_type, message.payload, p_message.id, sender), to=destination_node)
                # Wait for ACK timeout, i.e. 3 seconds
                timer = threading.Timer(3, retransmit_request, args=(
                    p_message, self.pending_message_acks))
                timer.start()
        else:
            p_message = create_playground_message(message, sender, destination)
            self.pending_message_acks[p_message.id] = False
            log_to_file("[Network-Playground] Send_Message  {}.".format(str(destination)))
            send((message.message_type, message.payload, p_message.id, sender), to=destination)
            # Wait for ACK timeout, i.e. 3 seconds
            timer = threading.Timer(3, retransmit_request, args=(
                p_message, self.pending_message_acks))
            timer.start()

    def retransmit_request(p_message, pending_acks):
        if self.playground_exited==True:
            print("Check retransmission of message  ", p_message.id, " required or not. However, Network Playground has Exited!! ")
            return
        log_to_file("[Network-Playground] Retransmit_request  {}.".format(str(p_message.id)))
        if pending_acks[p_message.id]==False:
            # Retransmit request if playground does not receive an ack within 3 seconds
            log_to_file("[Network-Playground] Retransmit Message with id: {} to destination".format(p_message._str_()))
            send_message(p_message.message, p_message.sender, p_message.destination, False)