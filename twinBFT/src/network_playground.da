from message import Message
from partition_view import PartitionView


class NetworkPlayground(process):
    def setup(partition_arrangement, nodes_mapping, nodes_obj_to_id_mapping):
        self.partition_arrangement = partition_arrangement
        self.nodes_mapping = nodes_mapping
        self.nodes_obj_to_id_mapping = nodes_obj_to_id_mapping

    def run():
        print("Starting Network Playground")
        print(str(nodes_mapping))
        print(str(nodes_obj_to_id_mapping))
        await False

    # def send_message(round, leader, message):
    #     partitions_wrt_round = partition_arrangement.get(round)
    #     partition_of_leader = find_partition(leader)
    #     other_nodes_in_the_same_partition = find_nodes_in_partition(partition_of_leader)
    #     for node in other_nodes_in_the_same_partition:
    #         send(message, node)

    def intra_partition_drop(message):
        partition_view = partition_arrangement[str(message.round)]
        if (partition_view["is_intra_partition_drop"] == True) \
                and (partition_view["intra_partition_drop_message_type"] == message.message_type) \
                and partition_view["intra_partition_drop_message_from"] == message.source:
            return True
        else:
            return False

    def filter(message):
        if intra_partition_drop(message):
            return True
        else:
            return False

    def find_nodes_in_partition(partition_sets, source):
        for partition in partition_sets:
            if source in partition:
                return partition
        return []

    def get_node_id(validator):
        #print("Get Node ID: {}. Keys: {}".format(validator, self.nodes_obj_to_id_mapping.keys()))
        if str(validator) not in  self.nodes_obj_to_id_mapping.keys():
            print("[Network-Playground] Something is wrong!!")
        id =  self.nodes_obj_to_id_mapping.get(str(validator))
        return id

    def determine_partition_of_validator(message, round, validator_id):
        partition_view = partition_arrangement[str(message.round)]['partition_set']
        for partition_set in partition_view:
            if validator_id in partition_set:
                print("[Network-Playground] Partition Set of validator {}: {}. Current partition view: {}".format(str(validator_id), str(partition_set), str(partition_view)))
                return partition_set

    def receive(msg=('Unicast', message), from_=sender):
        print("[Network-Playground] UNICAST message received : " + str(message))
        leader = message.destination
        round = message.round
        sender_id = get_node_id(sender)
        leader_id = self.get_node_id(leader)
        print("[Network-Playground] Sender_id: {} Leader_id: {}".format(str(sender_id), str(leader_id)))

        partition_set = determine_partition_of_validator(message, round, sender_id)

        if leader_id in partition_set:
            print("[Network-Playground] Both the Leader and Sender belong to the same partition. Forward the message to the leader...")
            send((message.message_type, message.payload, sender), to=leader)
        else:
            print("[Network-Playground] Leader isn't present in the same parition. Dropping current message....")
        # replace leader with test scenario plans


    def receive(msg=('Message', message), from_=sender):
        print("[Network-Playground] BROADCAST message received : {}. Sender: {} ".format(str(message), sender))
        destination = message.destination
        round = message.round
        sender_id = get_node_id(sender)
        print("Humara sender id is  " + str((sender_id)))
        partition_set = determine_partition_of_validator(message, round, sender_id)

        # Dropping message on filter criteria -> To Be Implemented
        # if filter(message):
        #     return

        filtered_next_nodes = []
        dropped_next_nodes = []
        for next_node in destination:
            next_node_id = get_node_id(next_node)
            if next_node_id in partition_set:
                filtered_next_nodes.append(next_node)
            else:
                dropped_next_nodes.append(next_node)

        passed_ids = [get_node_id(x) for x in filtered_next_nodes]
        dropped_ids = [get_node_id(x) for x in dropped_next_nodes]
        print("Message would be delivered to nodes: {}. Leaving nodes: {}".format(passed_ids, dropped_ids))

        # partition_sets = partition_arrangement[message.round]
        # other_nodes_in_the_same_partition = find_nodes_in_partition(partition_sets, message.source)
        # other_nodes_in_the_same_partition = nodes_mapping.values
        # if destination in other_nodes_in_the_same_partition:
        #     send((message.message_type, message.payload), to=nodes_mapping[destination])
        # else:
        #     print("Message Dropped due to partition")

        # destination_nodes = [nodes_mapping[id] for id in destination]
        #send((message.message_type, message.payload, sender), to=nodes_mapping.values())
        send((message.message_type, message.payload, sender), to=filtered_next_nodes)

        # Sending the message to its twin node as well
        # if (destination * -1) in other_nodes_in_the_same_partition:
        #     send((message.message_type, message.payload), to=nodes_mapping[(destination * -1)])
